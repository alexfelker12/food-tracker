generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//* -----------------------------
//* AUTH TABLES
//* -----------------------------

model User {
  id            String   @id
  name          String
  email         String   @unique // each user must have a unique email
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime

  // relations
  sessions       Session[]
  accounts       Account[]
  metricsProfile MetricsProfile?
  journalDay     JournalDay[]
  meal           Meal[]
  Food           Food[]

  // username plugin
  username        String?
  displayUsername String?

  // admin plugin
  role       String?   @default("user")
  banned     Boolean?  @default(false)
  banReason  String?
  banExpires DateTime?

  @@unique([username])
  @@index([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // admin plugin
  impersonatedBy String?

  @@index([userId, token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@index([identifier])
  @@map("verification")
}

//* -----------------------------
//* METRIC PROFILE TABLES (for now, not completed)
//* -----------------------------

enum Gender {
  MALE
  FEMALE
}

enum FitnessGoal {
  QUICKLY_LOSE_WEIGHT
  LOSE_WEIGHT
  MAINTAIN
  GAIN_WEIGHT
  QUICKLY_GAIN_WEIGHT
}

enum ActivityLevel {
  VERY_LOW
  LOW
  MEDIUM
  HIGH
  VERY_HIGH
}

enum BodyType {
  VERY_ATHELTIC
  ATHELTIC
  AVERAGE
  SLIGHTLY_OVERWEIGHT
  MORE_OVERWEIGHT
}

//* not used (for now?)
// enum DietaryStyle {
//   KETOGENIC
//   LOWCARB
//   HIGHCARBnutriment
//   BALANCED
// }

model MetricsProfile {
  id       String   @id @default(cuid())
  //* body metrics
  gender   Gender
  age      Int
  heightCm Int
  weightKg Float
  // bodyFat Float <- //* not used (for now?)
  bodyType BodyType

  //* fitness profile
  fitnessGoal         FitnessGoal
  activityLevel       ActivityLevel
  // dietaryStyle DietaryStyle <- //* not used (for now?)
  trainingDaysPerWeek Int
  // cardioDaysPerWeek Int <- //* not used (for now?)

  //* macro splits in percent %
  fatSplit     Int
  carbSplit    Int
  proteinSplit Int

  // relations
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  nutritionResult NutritionResult[]
}

model NutritionResult {
  id   String   @id @default(cuid())
  date DateTime @default(now()) @db.Date // stores result per date

  //* calculated calories/factors
  bmr        Float
  tdee       Float
  caloryGoal Float
  tefQuota   Float

  //* actual gram amount calculated from goal calories, tef quota and macro splits
  amountFats    Int
  amountCarbs   Int
  amountProtein Int

  // save profil data for potential future reference 
  profileSnapshot Json

  metricsProfileId String
  metricsProfile   MetricsProfile @relation(fields: [metricsProfileId], references: [id])

  // provides information about open and used calories for a JournalDay
  journalDay JournalDay[]

  // one result per profile per date
  @@unique([metricsProfileId, date])
  @@index([metricsProfileId])
}

//* -----------------------------
//* FOOD TABLES
//* -----------------------------

model Food {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // soft-delete marker to preserve journal history and meal integrity

  name  String
  brand String?

  // nutritional data (per 100g)
  kcal    Float
  fats    Float
  carbs   Float
  protein Float

  // created by
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // relations
  portions       FoodPortion[]
  journalEntries JournalEntry[]
  mealIngredient MealIngredient[]

  @@index([name])
  @@index([brand])
}

// defines one or more portion sizes for a food (e.g. 1 bar = 40g)
model FoodPortion {
  id     String @id @default(cuid())
  foodId String
  food   Food   @relation(fields: [foodId], references: [id], onDelete: Cascade)

  name      String // e.g. "1 bar", "1 scoop"
  grams     Float // weight of this portion in grams
  isDefault Boolean @default(false)

  journalEntry     JournalEntry[]
  portionReference PortionReference[]

  // prevent duplicate portion names per food
  @@unique([foodId, name])
  @@index([foodId])
}

//* -----------------------------
//* MEAL TABLES
//* -----------------------------

model Meal {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // soft-delete marker to preserve journal history

  name        String
  description String?

  // created by
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // relations
  ingredients    MealIngredient[]
  portions       MealPortion[]
  journalEntries JournalEntry[]

  @@index([userId])
  @@index([name])
}

// links a food as an ingredient in a meal with a gram amount
model MealIngredient {
  id     String @id @default(cuid())
  mealId String
  meal   Meal   @relation(fields: [mealId], references: [id], onDelete: Cascade)

  foodId String
  food   Food   @relation(fields: [foodId], references: [id], onDelete: Restrict)

  grams Float // how much of this food (in grams) is used in the meal

  portionLabel  String? // if ingridient was added through a portion save the name
  portionFactor Float? // and quantity of the portion to show it in the UI

  @@index([mealId])
}

// defines meal-specific portion sizes (e.g. "1 plate" = 250g)
model MealPortion {
  id     String @id @default(cuid())
  mealId String
  meal   Meal   @relation(fields: [mealId], references: [id], onDelete: Cascade)

  name      String
  grams     Float
  isDefault Boolean @default(false)

  portionReference PortionReference[]

  // prevent duplicate portion names per meal
  @@unique([mealId, name])
}

//* -----------------------------
//* JOURNAL TABLES
//* -----------------------------

enum MealType {
  BREAKFAST
  LUNCH
  DINNER
  SNACKS
}

model JournalDay {
  date DateTime @db.Date // one entry per user per day

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  journalEntries JournalEntry[]

  // caloryGoal is being used to calculate open calories for a JournalDay
  nutritionResultId String
  nutritionResult   NutritionResult @relation(fields: [nutritionResultId], references: [id])

  @@id(name: "journalDayId", fields: [userId, date])
  @@index([userId, date])
}

// represents a mapping between food/meal portions and journal entries
model PortionReference {
  id String @id @default(cuid())

  foodPortionId String?
  foodPortion   FoodPortion? @relation(fields: [foodPortionId], references: [id], onDelete: Cascade)
  mealPortionId String?
  mealPortion   MealPortion? @relation(fields: [mealPortionId], references: [id], onDelete: Cascade)

  grams Float // actual gram weight used
  label String // descriptive label for the portion used (e.g. "1/2 bar")

  @@index([foodPortionId])
  @@index([mealPortionId])
}

// represents a logged item (food or meal) in the daily journal
model JournalEntry {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  mealType  MealType @default(BREAKFAST)

  // link to journal day
  journalDayUserId String
  journalDayDate   DateTime   @db.Date
  journalDay       JournalDay @relation(fields: [journalDayUserId, journalDayDate], references: [userId, date], onDelete: Cascade)

  // reference to either food or meal (both optional but one required logically)
  foodId String?
  food   Food?   @relation(fields: [foodId], references: [id], onDelete: Restrict)
  mealId String?
  meal   Meal?   @relation(fields: [mealId], references: [id], onDelete: Restrict)

  // portion reference (which portion user used)
  portionId String
  portion   FoodPortion @relation(fields: [portionId], references: [id], onDelete: Restrict)

  amount Float @default(1) // how many portions/servings user tracked

  @@index([journalDayUserId, journalDayDate])
  @@index([foodId])
  @@index([mealId])
}
