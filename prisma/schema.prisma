datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client"
  output          = "../generated/prisma"
  previewFeatures = ["fullTextSearchPostgres"]
}

//* -----------------------------
//* AUTH TABLES
//* -----------------------------

model User {
  id            String   @id
  name          String
  email         String   @unique // each user must have a unique email
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime

  // relations
  sessions       Session[]
  accounts       Account[]
  metricsProfile MetricsProfile?
  meal           Meal[]
  Food           Food[]
  JournalEntries JournalEntry[]

  // username plugin
  username        String?
  displayUsername String?

  // admin plugin
  role       String?   @default("user")
  banned     Boolean?  @default(false)
  banReason  String?
  banExpires DateTime?

  @@unique([username])
  @@index([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // admin plugin
  impersonatedBy String?

  @@index([userId, token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@index([identifier])
  @@map("verification")
}

//* -----------------------------
//* METRIC PROFILE TABLES (for now, not completed)
//* -----------------------------

enum Gender {
  MALE
  FEMALE
}

enum FitnessGoal {
  QUICKLY_LOSE_WEIGHT
  LOSE_WEIGHT
  MAINTAIN
  GAIN_WEIGHT
  QUICKLY_GAIN_WEIGHT
}

enum ActivityLevel {
  VERY_LOW
  LOW
  MEDIUM
  HIGH
  VERY_HIGH
}

enum BodyType {
  VERY_ATHLETIC
  ATHLETIC
  AVERAGE
  SLIGHTLY_OVERWEIGHT
  MORE_OVERWEIGHT
}

model MetricsProfile {
  id String @id @default(cuid())

  //* user data
  // username in User table
  gender    Gender
  birthDate DateTime @db.Date

  //* body metrics
  heightCm Int
  weightKg Float
  bodyType BodyType

  //* fitness profile
  fitnessGoal         FitnessGoal
  activityLevel       ActivityLevel
  trainingDaysPerWeek Int

  //* macro splits in percent %
  fatSplit     Int
  carbSplit    Int
  proteinSplit Int

  // relations
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  nutritionResult NutritionResult[]
}

model NutritionResult {
  id   String   @id @default(cuid())
  date DateTime @default(now()) @db.Date // stores result per date

  //* calculated calories/factors
  bmr         Float
  tdee        Float
  caloryGoal  Float
  tefQuota    Float
  waterDemand Float

  //* actual gram amount calculated from goal calories, tef quota and macro splits
  amountFats    Int
  amountCarbs   Int
  amountProtein Int

  // save profil data for potential future reference 
  profileSnapshot       Json
  usedRecommendedSplits Boolean

  metricsProfileId String
  metricsProfile   MetricsProfile @relation(fields: [metricsProfileId], references: [id], onDelete: Cascade)

  // one result per profile per date
  @@unique([metricsProfileId, date])
  @@index([metricsProfileId])
}

//* -----------------------------
//* FOOD TABLES
//* -----------------------------

model Food {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // soft-delete marker to preserve journal history and meal integrity

  name  String
  brand String?

  // nutritional data (per 100g)
  kcal    Float
  fats    Float
  carbs   Float
  protein Float //? maybe fix someday? missed plural form here (protein*s*) ...

  // created by
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // relations
  portions             FoodPortion[]
  mealIngredient       MealIngredient[]
  consumableReferences ConsumableReference[]

  @@index([name])
  @@index([brand])
}

// defines one or more portion sizes for a food (e.g. 1 bar = 40g)
model FoodPortion {
  id String @id @default(cuid())

  foodId String
  food   Food   @relation(fields: [foodId], references: [id], onDelete: Cascade)

  name      String // e.g. "1 bar", "1 scoop"
  grams     Float // weight of this portion in grams
  isDefault Boolean @default(false)

  consumableReference ConsumableReference[]

  // prevent duplicate portion names per food
  @@unique([foodId, name])
  @@index([foodId])
}

//* -----------------------------
//* MEAL TABLES
//* -----------------------------

model Meal {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // soft-delete marker to preserve journal history

  name        String
  description String?

  // created by
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // relations
  ingredients          MealIngredient[]
  portions             MealPortion[]
  consumableReferences ConsumableReference[]

  @@index([userId])
  @@index([name])
}

// links a food as an ingredient in a meal with a gram amount
model MealIngredient {
  id     String @id @default(cuid())
  mealId String
  meal   Meal   @relation(fields: [mealId], references: [id], onDelete: Cascade)

  foodId String
  food   Food   @relation(fields: [foodId], references: [id], onDelete: Restrict)

  grams Float // how much of this food (in grams) is used in the meal

  portionLabel  String? // if ingridient was added through a portion save the name
  portionFactor Float? // and quantity of the portion to show it in the UI

  @@index([mealId])
}

// defines meal-specific portion sizes (e.g. "1 plate" = 250g)
model MealPortion {
  id String @id @default(cuid())

  mealId String
  meal   Meal   @relation(fields: [mealId], references: [id], onDelete: Cascade)

  name      String
  grams     Float
  isDefault Boolean @default(false)

  consumableReference ConsumableReference[]

  // prevent duplicate portion names per meal
  @@unique([mealId, name])
}

//* -----------------------------
//* JOURNAL TABLES
//* -----------------------------

enum IntakeTime {
  BREAKFAST
  LUNCH
  DINNER
  SNACKS
}

// represents a (loose) reference to the track food/meal with its portion
// if food/meal or the portion is not trackable anymore, data will fall back to defaults
model ConsumableReference {
  id String @id @default(cuid())

  // reference to either food/foodPortion or meal/mealPortion (both optional but one required logically)
  foodId        String?
  food          Food?        @relation(fields: [foodId], references: [id], onDelete: Restrict)
  foodPortionId String?
  foodPortion   FoodPortion? @relation(fields: [foodPortionId], references: [id], onDelete: SetNull)

  mealId        String?
  meal          Meal?        @relation(fields: [mealId], references: [id], onDelete: Restrict)
  mealPortionId String?
  mealPortion   MealPortion? @relation(fields: [mealPortionId], references: [id], onDelete: SetNull)

  journalEntryId String       @unique
  journalEntry   JournalEntry @relation(fields: [journalEntryId], references: [id], onDelete: Cascade)
}

// represents a logged item (food or meal) in the daily journal
model JournalEntry {
  id         String     @id @default(cuid())
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  intakeTime IntakeTime @default(BREAKFAST)

  // link to user by date
  date   DateTime @db.Date
  userId String
  user   User     @relation(fields: [userId], references: [id])

  //* historical snapshot of food data/macros 
  name     String
  brand    String?
  // final macro values calculated with portion data/amount
  kcal     Float
  fats     Float
  carbs    Float
  proteins Float

  // portion data
  portionName   String?
  portionAmount Float

  consumableReference ConsumableReference?

  @@index([userId, date])
}
